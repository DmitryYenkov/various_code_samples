%% Опыты с вращением вектора через кватернион
%
% Начальный вектор:
vect0 = [2 3 5]';
% Конечный вектор:
vect1 = [-3 -8 7]';
% Это либо точки, куда они направлены (из нуля, или из своего начала, т.к.
% координаты вектора - это длины проекций на оси. Если начальный и конечный
% вектора отличаются по длине - значит будет иметь место растяжение,
% которое тоже отобразим.
%
% Отрисуем:
figure(1);clf;hold all;grid on;xlabel('X');ylabel('Y');zlabel('Z');view(30,30);
% Разность векторов - из второго вычесть первый
% (направлена из конца первого в конец второго
vect1_0 = vect1 - vect0;
% А теперь все это можно сместить в начальную точку:
pt0 = [1 1 1]';
% 
plot3([0 vect0(1)] + pt0(1), [0 vect0(2)] + pt0(1), [0 vect0(3)] + pt0(1));
plot3([0 vect1(1)] + pt0(1), [0 vect1(2)] + pt0(1), [0 vect1(3)] + pt0(1));
% А к разности - еще и конец первого вектора прибавить:
plot3([0 vect1_0(1)] + pt0(1) + vect0(1), [0 vect1_0(2)] + pt0(1) + vect0(2), [0 vect1_0(3)] + pt0(1) + vect0(3));
%
% далее:
% Длины:
lv0 = norm(vect0);
lv1 = norm(vect1);
lv1_0 = norm(vect1_0);
% Отношение конечно длины к начальной - это растяжение/сжатие
kl = lv1 / lv0; % это общее. 
% А по осям отдельно: для этого берем отношения координат, 
% берем их по модулю, и делаем диагональную матрицу:
klx = diag(abs(vect1 ./ vect0));
% хотя оказалось, что это и не нужно
%
% теперь нормирование начального вектора:
vect0n = vect0 / lv0;
% нормирование конечного:
vect1n = vect1 / lv1;
% 
% Ось вращение от 0 к 1 вектору образует правую тройку, 
% значит координаты вектора вращения:
vect01r = [vect0(2) * vect1(3) - vect0(3) * vect1(2), ...
           vect0(3) * vect1(1) - vect0(1) * vect1(3), ...
           vect0(1) * vect1(2) - vect0(2) * vect1(1)]';
% а нормированный:
% значит его координаты:
vect01rn = [vect0n(2) * vect1n(3) - vect0n(3) * vect1n(2), ...
            vect0n(3) * vect1n(1) - vect0n(1) * vect1n(3), ...
            vect0n(1) * vect1n(2) - vect0n(2) * vect1n(1)]';
% Почему-то его длина (норма) получилась не строго равна 1 (0.9973)
% хотя должна (нормы векторов vect0, vect1n = 1
% Поэтому его тоже нормируем до единичной длины:
vect01rn = vect01rn / norm(vect01rn);
% 
% Угол между векторами 0 и 1:
a01 = acos(sum(vect0n .* vect1n)); % в радианах
% это то же самое что
a01_ = acos(sum(vect0 .* vect1) / norm(vect0) / norm(vect1));
%
%% КВАТЕРНИОН
% написано на основании статьи:
% https://www.pvsm.ru/matematika/88039
%
% Кватернион вращения от 0 к 1 вектору:
quat01r = [cos(a01/2); sin(a01/2) * vect01rn]; % 4-хэлементный вектор
% норма его равна 1.
%
% Повороты 
%
% Умножение кватернионов.
% Результатом умножения является кватернион, 
% который после поворота даёт такой же результат, 
% если последовательно выполнить развороты умножаемыми кватернионами. 
% Причём разворот будет происходить в локальной 
% для поворачиваемого вектора системе отчёта, 
% т. е. система отчёта поворачиваемого вектора также двигается.
%
% Разобьем наш поворот на 2 и проверим:
quat01r2 = [cos(a01/4); sin(a01/4) * vect01rn];
% Умножение реализовано в вызываемой функции qxq.m
quat01rm = qxq(quat01r2, quat01r2);
% Результат совпадает с quat01r
%
% Теперь проверим умножение вектора через кватернион.
% Для того, чтобы умножить кватернион на 3D вектор, 
% нужно вектор преобразовать в кватернион,
% присвоив компоненте W = 0 и умножить кватернион на кватернион.
% Это реализует вызываемая функция qxv.m
vectxq = qxv(quat01r, vect0n); 
%
% Далее, для поворота вектора нужно данный кватернион (этот результат
% умножения) умножить на кватернион, обратный кватерниону вращения.
% Так указано в формулах.
% Все это вместе (2 операции) реализует функция vrq.m
vect0rn = vrq(vect0n, quat01r);
% результат полностью совпал с нормированным вектором vect1n
%
% Теперь то же самое с вектором полной длины и масштабированием:
vect0r = kl * vrq(vect0, quat01r);
% округлим, т.к. в результате ограниченной точности представления
% данных в компьютере получается окончание целых чисел в виде:
% .999999999999 или .00000000000001
vect0r = round(vect0r, 12);
%
% отрисуем нормированные вектора и ось вращения:
plot3([0 vect0n(1)] + pt0(1), [0 vect0n(2)] + pt0(1), [0 vect0n(3)] + pt0(1));
plot3([0 vect01rn(1)] + pt0(1), [0 vect01rn(2)] + pt0(1), [0 vect01rn(3)] + pt0(1));
plot3([0 vect0rn(1)] + pt0(1), [0 vect0rn(2)] + pt0(1), [0 vect0rn(3)] + pt0(1));
legend('v0', 'v1', 'v1-v0', 'v0norm', 'rot.axis', 'v0norm rot.');
%
%% Проверка функций МАТЛАБ
%
% Расчет вектора вращения исходя из заданных начального и конечного
% векторов:
vrrot = vrrotvec(vect0n, vect1n);
% В результате получается представление axang - axis and angle - 
% т.е. 3 первые элемента - совпадают с нормированным вектором вращения 
% vect01rn, а последний - равен углу вращения a01.
% И совпадает с элементами 2,3,4 кватерниона, а 1 элемент кватерниона - 
% это косинус половины этого угла.
%
% Получение axang-представления из кватерниона:
axan = quat2axang(quat01r');
% тоже совпадает.
%
% Получение матрицы вращения из axang-представления:
rotm = axang2rotm(axan);
% 
% Получение матрицы вращения из кватерниона:
rotmq = rotmat(quaternion(quat01r'),'point');
% совпадает с rotm
%
% Получение углов Эйлера из матрицы вращения:
eul = rotm2eul(rotm);
% и из кватерниона:
eulq = quat2eul(quaternion(quat01r'), 'ZYX');
% совпадает
%
%% 
% В функциях qxv, qxq, vrq возможно использование кватерниона как в виде
% 4-хэлементного вектора, так и в виде объекта quaternion МАТЛАБА.
q = quaternion(quat01r');
% Последнее кажется менее удобным, т.к. тогда доступ к его элементам
% только черех функцию parts:
[qw, qx, qy, qz] = parts(q);
%
% Таким образом, когда есть два вектора - начальный и конечный - можно
% вычислить угол и ось вращения, затем, если необходима дискретизация,
% разбить этот угол на нужное число элементарных углов. Для 
% элементарного угла малой величины определить кватернион.
% Тогда последовательное вращение по шагам от начального к конечному будет
% представлять собой vrq - вращение вектора через этот элементарный 
% кватернион, где в качестве вектора подставляется результат предыдущего
% поворота.

%% Пересмотр способа формирования кватерниона (с помощью угла и вектора).
%
rl = 1;
r = [rl 0 0]';
dt = 1;
[x, y, z] = sph2cart(deg2rad(5), deg2rad(8), 1);
rr = [x y z]';
a = acos(dot(r, rr) / norm(r) / norm(rr));
cr = cross(r, rr);
q = av2quat(a, cr)
wm = a / dt;
w = wm * cr / norm(cr);
v = cross(w, r)
